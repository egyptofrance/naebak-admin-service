# ADR-001: نظام الأدوار والصلاحيات المتعدد

## الحالة
مقبول

## السياق والمشكلة

في منصة نائبك، نحتاج إلى نظام صلاحيات مرن وقابل للتوسع لإدارة المستخدمين الإداريين. التحدي الرئيسي هو كيفية تصميم نظام يدعم:

- **تعدد الأدوار:** مستخدم واحد قد يحتاج أدوار متعددة (مثل: مشرف محتوى + مشرف شكاوى)
- **الصلاحيات المرنة:** إمكانية تخصيص صلاحيات فردية بجانب الأدوار
- **الإدارة الهرمية:** مديرين عامين، مديرين إقليميين، مشرفين متخصصين
- **قابلية التوسع:** إضافة أدوار وصلاحيات جديدة دون تعديل الكود

## البدائل المدروسة

### البديل 1: نظام الأدوار الواحد (Single Role)
```python
class AdminUser(AbstractUser):
    role = models.CharField(choices=ADMIN_ROLES)
```

**المزايا:**
- بساطة التطبيق والفهم
- أداء سريع في الاستعلامات
- سهولة إدارة الصلاحيات

**العيوب:**
- عدم مرونة في تعيين أدوار متعددة
- صعوبة في التوسع المستقبلي
- تكرار في الأدوار للمستخدمين ذوي المسؤوليات المتعددة

### البديل 2: الصلاحيات المباشرة فقط (Direct Permissions Only)
```python
class AdminUser(AbstractUser):
    permissions = models.ManyToManyField(Permission)
```

**المزايا:**
- مرونة كاملة في تخصيص الصلاحيات
- دقة في التحكم بالوصول
- لا توجد طبقات إضافية

**العيوب:**
- تعقيد في الإدارة لعدد كبير من المستخدمين
- صعوبة في تجميع الصلاحيات المترابطة
- عرضة للأخطاء البشرية في التخصيص

### البديل 3: نظام الأدوار المتعدد (Multi-Role System) - المختار
```python
class AdminUser(AbstractUser):
    admin_roles = models.ManyToManyField(AdminRole)
    # + صلاحيات مباشرة من Django الأساسي

class AdminRole(models.Model):
    permissions = models.ManyToManyField(Permission)
```

## القرار المتخذ

اخترنا **نظام الأدوار المتعدد** مع دعم الصلاحيات المباشرة للأسباب التالية:

### المبررات التقنية

1. **المرونة القصوى:**
   - مستخدم واحد يمكن أن يحمل أدوار متعددة
   - إمكانية إضافة صلاحيات فردية خاصة
   - سهولة إعادة تنظيم الأدوار دون تأثير على المستخدمين

2. **قابلية الصيانة:**
   - تجميع الصلاحيات المترابطة في أدوار منطقية
   - سهولة إضافة أدوار جديدة للميزات المستقبلية
   - إدارة مركزية للصلاحيات عبر الأدوار

3. **الأداء المحسن:**
   - استعلامات محسنة مع فهارس على الأدوار
   - تخزين مؤقت للصلاحيات المتكررة
   - تقليل عدد الاستعلامات للتحقق من الصلاحيات

### التطبيق التقني

```python
# فحص الصلاحيات المدمج
def has_admin_permission(self, permission_codename):
    """فحص صلاحية من الأدوار أو الصلاحيات المباشرة"""
    return (
        self.user_permissions.filter(codename=permission_codename).exists() or
        self.admin_roles.filter(
            permissions__codename=permission_codename, 
            is_active=True
        ).exists()
    )

# أمثلة على الأدوار المحددة مسبقاً
PREDEFINED_ROLES = {
    'super_admin': ['*'],  # جميع الصلاحيات
    'content_moderator': ['view_content', 'edit_content', 'delete_content'],
    'complaint_manager': ['view_complaints', 'assign_complaints', 'resolve_complaints'],
    'user_manager': ['view_users', 'edit_users', 'suspend_users'],
}
```

### أمثلة الاستخدام

```python
# مستخدم بأدوار متعددة
admin_user = AdminUser.objects.create(username='ahmed_manager')
admin_user.admin_roles.add(
    AdminRole.objects.get(role_type='content_moderator'),
    AdminRole.objects.get(role_type='complaint_manager')
)

# إضافة صلاحية خاصة
special_permission = Permission.objects.get(codename='export_statistics')
admin_user.user_permissions.add(special_permission)

# فحص الصلاحيات
if admin_user.has_admin_permission('view_complaints'):
    # السماح بعرض الشكاوى
    pass
```

## العواقب

### النتائج الإيجابية

1. **مرونة في الإدارة:**
   - سهولة تعيين أدوار متعددة للمستخدمين
   - إمكانية تخصيص صلاحيات فردية عند الحاجة
   - سرعة في إعادة تنظيم الأدوار

2. **قابلية التوسع:**
   - إضافة أدوار جديدة دون تعديل الكود الأساسي
   - دعم للميزات المستقبلية والتوسعات
   - تكامل سلس مع نظام Django الأساسي

3. **الأمان المحسن:**
   - تحكم دقيق في الصلاحيات
   - إمكانية تعطيل أدوار كاملة فوراً
   - تتبع شامل للصلاحيات والتغييرات

### التحديات المحتملة

1. **تعقيد الاستعلامات:**
   - استعلامات أكثر تعقيداً للتحقق من الصلاحيات
   - الحاجة لتحسين الأداء مع نمو البيانات

2. **إدارة التضارب:**
   - إمكانية تضارب بين صلاحيات الأدوار المختلفة
   - الحاجة لقواعد واضحة لحل التضارب

### استراتيجيات التخفيف

1. **تحسين الأداء:**
```python
# استخدام select_related و prefetch_related
admin_user = AdminUser.objects.select_related('governorate').prefetch_related(
    'admin_roles__permissions', 'user_permissions'
).get(id=user_id)

# تخزين مؤقت للصلاحيات
@cached_property
def cached_permissions(self):
    return set(self.get_all_permissions())
```

2. **قواعد حل التضارب:**
   - الصلاحيات المباشرة لها أولوية على أدوار
   - في حالة تضارب الأدوار، الأكثر تقييداً يفوز
   - تسجيل جميع حالات التضارب في سجل النشاطات

3. **واجهة إدارة محسنة:**
   - عرض مرئي لجميع صلاحيات المستخدم
   - تحذيرات عند وجود تضارب محتمل
   - معاينة الصلاحيات قبل الحفظ

## المراجعة والتقييم

### معايير النجاح
- سهولة إضافة أدوار جديدة (< 5 دقائق)
- أداء فحص الصلاحيات (< 50ms)
- رضا المديرين عن مرونة النظام (> 90%)

### جدولة المراجعة
- **مراجعة أولى:** بعد 3 أشهر من التطبيق
- **مراجعة دورية:** كل 6 أشهر
- **مراجعة طارئة:** عند إضافة 10+ أدوار جديدة

### مؤشرات المراقبة
- عدد الاستعلامات لفحص الصلاحيات
- وقت الاستجابة لعمليات التحقق
- عدد حالات التضارب المسجلة
- معدل استخدام الصلاحيات المباشرة مقابل الأدوار

---

**تاريخ الإنشاء:** سبتمبر 2024  
**المؤلف:** فريق تطوير نائبك  
**المراجعون:** فريق الأمان، فريق الأداء  
**الحالة:** مقبول ومطبق
